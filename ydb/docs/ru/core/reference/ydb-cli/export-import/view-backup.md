# Резервное копирование и восстановление представлений (views)

Эта статья рассказывает об особенностях резервного копирования и восстановления [представлений](../../../concepts/datamodel/view.md) (views) в {{ ydb-short-name }}. Описанное ниже [преобразование запроса при восстановлении](#преобразование-запроса-при-восстановлении) применяется для:

- локальных резервных копий (смотри команды [ydb tools dump](./_includes/tools-dump.md) и [ydb tools restore](./_includes/tools-restore.md))
- резервных копий в S3-совместимых хранилищах (смотри команды [ydb export s3](./_includes/export-s3.md) и [ydb import s3](./_includes/import-s3.md))

## Преобразование запроса при восстановлении

Представления в {{ ydb-short-name }} выгружаются в форме SQL-определения [CREATE VIEW](../../../yql/reference/syntax/create-view.md) (подробнее о формате резервных копий представлений можно прочитать в статье ["Файловая структура выгрузки"](./file-structure.md#views)). При восстановлении из резервной копии такие текстовые определения специальным образом преобразовываются, чтобы обеспечить корректность [путей к объектам внутри SQL-запроса представления](#пути-к-объектам-внутри-sql-запроса-представления) в целевой базе данных.

## Пути к объектам внутри SQL-запроса представления

Представления могут ссылаться на схемные объекты (таблицы или другие представления) с использованием абсолютных или относительных путей. Абсолютные пути начинаются с символа `'/'`. В начало относительных путей добавляется [TablePathPrefix](../../../yql/reference/syntax/pragma#table-path-prefix), чтобы получить соответствующий абсолютный путь.

{% note info %}

Следует иметь в виду, что прагма `TablePathPrefix` никогда не бывает пустой или неустановленной. Если пользователь явно не указывает значение для неё, система автоматически выставляет значение по умолчанию, равное корню базы данных.

{% endnote %}

Для примера допустим, что представление создаётся следующим запросом:

```sql
CREATE VIEW `view` WITH (security_invoker = TRUE) AS
    SELECT
        seasons.title AS seasons_title,
        episodes.title AS episodes_title,
        seasons.series_id AS series_id
    FROM `/my_database_root/seasons`
        AS seasons
    JOIN `episodes`
        AS episodes
    ON seasons.series_id == episodes.series_id
```

В `SELECT` запросе видны:

- `/my_database_root` - корень базы
- `/my_database_root/seasons` - ссылка на объект (это может быть как таблица, так и представление) в форме абсолютного пути
- `episodes` - ссылка на объект в форме относительного пути, который соответствует абсолютному пути `/my_database_root/episodes`

### Правила преобразования запросов

Преобразование запроса выполняется согласно следующим правилам:

- Исходный путь к объекту разделяется на две части:

    ```text
    исходный_путь_к_объекту = корень_бекапа + путь_относительно_корня_бекапа
    ```

    где `корень_бекапа` - это значение опции `--path` команды [ydb tools dump](./_includes/tools_dump.md)

- При восстановлении каждая ссылка модифицируется так, чтобы указывать на объект с аналогичным положением относительно корня восстановления:

    ```text
    ссылка_после_восстановления = корень_восстановления + путь_относительно_корня_бекапа
    ```

    где `корень_восстановления` - это значение опции `--path` команды [ydb tools restore](./_includes/tools_restore.md)

Это обеспечивает корректность ссылок внутри представлений после восстановления.

#### Относительные пути

В абсолютных путях заменяется префикс `корень_бекапа` на `корень_восстановления` (подробнее об этом написано [выше](#правила-преобразования-запросов)). Относительные пути сначала преобразовываются в абсолютные пути с помощью прагмы [TablePathPrefix](../../../yql/reference/syntax/pragma#table-path-prefix):

```text
абсолютный_путь = table_path_prefix + относительный_путь
```

Предполагается, что прагма `table_path_prefix` является подпутём корня бекапа, а значит переписать достаточно только её. Процедура восстановления переписывает её согласно общему правилу:

1. Прагма разбивается на две части:

    ```text
    исходный_префикс = корень_бекапа + префикс_относительно_корня_бекапа
    ```

2. Значение прагмы после восстановления получается заменой корня бекапа на корень восстановления:

    ```text
    префикс_после_восстановления = корень_восстановления + префикс_относительно_корня_бекапа
    ```

Если представление неявно использовало корень базы данных в качестве `TablePathPrefix` и восстановление происходит не в корень целевой базы, а ниже, то процедура восстановления автоматически выставляет прагму `TablePathPrefix` в SQL-запросе на создание представления. В этом можно убедиться, проверив текст запроса восстановленного представления с помощью команды:

```bash
ydb scheme describe <путь_к_восстановленному_представлению>
```

### Примеры

#### Абсолютный путь

Рассмотрим следующий сценарий:

1. Пользователь создаёт представление при помощи следующего запроса:

    ```sql
    CREATE VIEW my_view WITH security_invoker = TRUE AS
    SELECT * FROM `/my_database/my_table`;
    ```

    Заметим, что таблица `my_table` адресуется абсолютным путём.

2. Пользователь выгружает базу данных, используя {{ ydb-short-name }} CLI:

    ```bash
    ydb --database /my_database --endpoint <endpoint> tools dump --path . --output ./my_backup
    ```

3. Позже пользователь создает новую базу данных, например, с именем `target_db`.

4. В момент восстановления данных из ранее сделанной резервной копии:

    ```bash
    ydb --database /target_db --endpoint <endpoint> tools restore --path . --input ./my_backup
    ```

    утилита {{ ydb-short-name }} CLI автоматически переписывает SQL-запрос из файла `create_view.sql` так, чтобы ссылка указывала на таблицу `/target_db/my_table` вместо изначальной `/my_database/my_table`.

#### Неявно заданная прагма TablePathPrefix

Допустим следующую ситуацию:

1. Пользователь создал исходное представление без явного указания прагмы `TablePathPrefix`:

    ```sql
    CREATE VIEW my_view WITH security_invoker = TRUE AS
    SELECT * FROM my_table;
    ```

2. Резервная копия сделана следующим образом:

    ```bash
    ydb --database /my_database --endpoint <endpoint> tools dump --path . --output ./my_backup
    ```

3. Восстановление выполнено в ту же базу данных, но в другую подпапку:

    ```bash
    ydb --database /my_database --endpoint <endpoint> tools restore --path ./restore/point --input ./my_backup
    ```

4. В результате восстановленное представление будет указывать на таблицу `/my_database/restore/point/my_table` вместо исходного пути `/my_database/my_table`.

5. Убедиться в этом можно, проверив текст запроса представления командой:

    ```bash
    ydb scheme describe restore/point/my_view
    ```

    В выводе команды видна прагма `TablePathPrefix`:

    ```text
    <view> my_view

    Query text:
    PRAGMA TablePathPrefix = '/my_database/restore/point';
    SELECT * FROM my_table
    ```
