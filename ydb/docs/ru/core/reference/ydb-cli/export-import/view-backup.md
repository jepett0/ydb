# Резервное копирование и восстановление представлений (views)

Эта статья рассказывает об особенностях резервного копирования и восстановления [представлений](../../../concepts/datamodel/view.md) (views) в {{ ydb-short-name }}.

## Организация файлов резервной копии

В основном резервное копирование представлений аналогично резервному копированию таблиц:

- Каждый объект схемы (таблица, представление и т.д.) представлен в резервной копии папкой (назовём её `object_directory`), расположенной в том же месте относительно корня папки резервного копирования (задаётся параметром `--output` команды `ydb tools dump`), в котором расположен объект относительно корня базы данных (задаётся параметром `--path`).
- Каждая папка объекта (`object_directory`) содержит файл, описывающий данный схемный объект.

Однако, форматы резервных копий для представлений и таблиц различаются:

| Тип объекта   | Файл резервной копии             | Формат                                                  |
|---------------|----------------------------------|---------------------------------------------------------|
| Таблица       | scheme.pb                        | Protobuf сообщение `CreateTableRequest`                 |
| Представление | create_view.sql                  | Текстовый SQL запрос `CREATE VIEW`                      |

Таким образом, при восстановлении:

- таблицы восстанавливаются из protobuf-описания (`scheme.pb`)
- представления — путём исполнения `CREATE VIEW` запросов

## Переписывание запроса при восстановлении

Как обсуждалось в предыдущем [параграфе](#организация-файлов-резервной-копии), представления в {{ ydb-short-name }} выгружаются в форме SQL-определения `CREATE VIEW`. При восстановлении из резервной копии такие текстовые определения специальным образом переписываются, чтобы обеспечить корректность путей к объектам внутри SQL-запроса представления в целевой базе данных.

### Пример

Рассмотрим следующий сценарий:

1. Пользователь создаёт представление при помощи следующего запроса:

```sql
CREATE VIEW my_view WITH security_invoker = TRUE AS
SELECT * FROM `/my_database/my_table`;
```

Заметим, что таблица `my_table` адресуется абсолютным путём.

2. Пользователь выгружает базу данных, используя {{ ydb-short-name }} CLI:

```bash
ydb --database /my_database --endpoint <endpoint> tools dump --path . --output ./my_backup
```

3. Позже пользователь создает новую базу данных, например, с именем `target_db`.

4. В момент восстановления данных из ранее сделанной резервной копии:

```bash
ydb --database /target_db --endpoint <endpoint> tools restore --path . --input ./my_backup
```

утилита {{ ydb-short-name }} CLI автоматически переписывает SQL-запрос из файла `create_view.sql` так, чтобы ссылка указывала на таблицу `/target_db/my_table` вместо изначальной `/my_database/my_table`.

### Правила переписывания запросов

Переписывание запроса выполняется согласно следующим правилам:

- Исходный путь к объекту разделяется на две части:

```text
исходный_путь_к_объекту = корень_бекапа + путь_относительно_корня_бекапа
```

- При восстановлении каждая ссылка модифицируется так, чтобы указывать на объект с аналогичным положением относительно корня восстановления (значения `--path` параметра `ydb tools restore` команды):

```text
ссылка_после_восстановления = корень_восстановления + путь_относительно_корня_бекапа
```

Это обеспечивает корректность ссылок внутри представлений после восстановления.

#### Относительные пути

Представления могут ссылаться на схемные объекты (таблицы или другие представления) с использованием абсолютных или относительных путей. Абсолютные пути переписываются путём замены префикса `корень_бекапа` на `корень_восстановления`. Относительные пути переписываются аналогичным образом, путём их предварительного преобразования в абсолютные пути с помощью прагмы [TablePathPrefix](../../../yql/reference/syntax/pragma#table-path-prefix):

```text
абсолютный_путь = TablePathPrefix + относительный_путь
```

Предполагается, что прагма `TablePathPrefix` является подпутём корня бекапа, а значит переписать достаточно только её. Процедура восстановления переписывает её согласно общему правилу:

1. Прагма разбивается на две части:

```text
исходный_префикс = корень_бекапа + префикс_относительно_корня_бекапа
```

2. Значение прагмы после восстановления получается заменой корня бекапа на корень восстановления:

```text
префикс_после_восстановления = корень_восстановления + префикс_относительно_корня_бекапа
```

Следует иметь в виду, что прагма `TablePathPrefix` никогда не бывает пустой или неустановленной. Если пользователь явно не указывает значение для неё, система автоматически выставляет значение по умолчанию, равное корню базы данных. Если представление неявно использовало корень базы данных в качестве `TablePathPrefix` и восстановление происходит не в корень целевой базы, а ниже, то процедура восстановления автоматически выставляет прагму `TablePathPrefix` в SQL-запросе на создание представления. В этом можно убедиться, проверив текст запроса восстановленного представления с помощью команды:

```bash
ydb scheme describe <путь_к_восстановленному_представлению>
```

#### Пример

Допустим следующую ситуацию:

1. Пользователь создал исходное представление без явного указания прагмы `TablePathPrefix`:

```sql
CREATE VIEW my_view WITH security_invoker = TRUE AS
SELECT * FROM my_table;
```

2. Резервная копия сделана следующим образом:

```bash
ydb --database /my_database --endpoint <endpoint> tools dump --path . --output ./my_backup
```

3. Восстановление выполнено в ту же базу данных, но в другую подпапку:

```bash
ydb --database /my_database --endpoint <endpoint> tools restore --path ./restore/point --input ./my_backup
```

4. В результате восстановленное представление будет указывать на таблицу `/my_database/restore/point/my_table` вместо исходного пути `/my_database/my_table`.

5. Убедиться в этом можно, проверив текст запроса представления командой:

```bash
ydb scheme describe restore/point/my_view
```

В выводе команды видна прагма `TablePathPrefix`:

```text
<view> my_view

Query text:
PRAGMA TablePathPrefix = '/my_database/restore/point';
SELECT * FROM my_table
```
